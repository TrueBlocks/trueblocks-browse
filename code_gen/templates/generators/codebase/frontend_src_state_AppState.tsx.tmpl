// This file is auto-generated. Edit only code inside
// of ExistingCode markers (if any).
import { useState, useEffect, useContext, useCallback, createContext, ReactNode } from "react";
import {
{{range .Structures}}  {{firstUpper .UiRouteName}}Page,
{{end}}  SetChain,
  StatusPage,
  SessionPage,
  GetAppInfo,
} from "@gocode/app/App";
import { app, base, messages, types } from "@gocode/models";
import { EventsOff, EventsOn } from "@runtime";

interface AppStateProps {
{{range .Structures}}  {{toLower .UiRouteName}}: types.{{.Class}}Container;
  fetch{{firstUpper .UiRouteName}}: (currentItem: number, itemsPerPage: number) => void;

{{end}}  address: base.Address;
  setAddress: (address: base.Address) => void;

  info: app.AppInfo;
  chain: string;
  meta: types.MetaData;
  isConfigured: boolean;
  wizardState: types.WizState;
  setHistory: React.Dispatch<React.SetStateAction<types.HistoryContainer>>;
  selectChain: (newChain: string) => void;
  setMeta: (meta: types.MetaData) => void;
  setWizardState: (state: types.WizState) => void;
}

const AppState = createContext<AppStateProps | undefined>(undefined);

export const AppStateProvider: React.FC<{ children: ReactNode }> = ({ children }: { children: ReactNode }) => {
{{range .Structures}}  const [{{toLower .Class}}, set{{.Class}}] = useState<types.{{.Class}}Container>({} as types.{{.Class}}Container);
{{end}}  // TODO BOGUS: The daemon state should be in the AppState

  const [address, setAddress] = useState<base.Address>("0x0" as unknown as base.Address);

  const [chain, setChain] = useState<string>("mainnet");
  const [isConfigured, setIsConfigured] = useState<boolean>(false);
  const [wizardState, setWizardState] = useState<types.WizState>(types.WizState.WELCOME);
  const [meta, setMeta] = useState<types.MetaData>({} as types.MetaData);
  const [info, setInfo] = useState<app.AppInfo>({} as app.AppInfo);

  const fetchProject = useCallback((currentItem: number, itemsPerPage: number) => {
    ProjectPage(currentItem, itemsPerPage).then((item: types.ProjectContainer) => {
      setProject(item);
    });
  }, []);

  const fetchHistory = useCallback((currentItem: number, itemsPerPage: number) => {
    HistoryPage(String(address), currentItem, itemsPerPage).then((item: types.HistoryContainer) => {
      setHistory(item);
    });
  }, []);

  const fetchMonitors = useCallback((currentItem: number, itemsPerPage: number) => {
    MonitorsPage(currentItem, itemsPerPage).then((item: types.MonitorContainer) => {
      if (item) {
        setMonitors(item);
      }
    });
  }, []);

  const fetchNames = useCallback((currentItem: number, itemsPerPage: number) => {
    NamePage(currentItem, itemsPerPage).then((item: types.NameContainer) => {
      if (item) {
        setNames(item);
      }
    });
  }, []);

  const fetchAbis = useCallback((currentItem: number, itemsPerPage: number) => {
    AbiPage(currentItem, itemsPerPage).then((item: types.AbiContainer) => {
      if (item) {
        setAbis(item);
      }
    });
  }, []);

  const fetchIndexes = useCallback((currentItem: number, itemsPerPage: number) => {
    IndexPage(currentItem, itemsPerPage).then((item: types.IndexContainer) => {
      if (item) {
        setIndexes(item);
      }
    });
  }, []);

  const fetchManifests = useCallback((currentItem: number, itemsPerPage: number) => {
    ManifestPage(currentItem, itemsPerPage).then((item: types.ManifestContainer) => {
      if (item) {
        setManifests(item);
      }
    });
  }, []);

  const fetchSettings = useCallback((currentItem: number, itemsPerPage: number) => {
    SettingsPage(currentItem, itemsPerPage).then((item: types.SettingsContainer) => {
      if (item) {
        setSettings(item);
      }
    });
  }, []);

  const fetchStatus = useCallback((currentItem: number, itemsPerPage: number) => {
    StatusPage(currentItem, itemsPerPage).then((item: types.StatusContainer) => {
      if (item) {
        setStatus(item);
      }
    });
  }, []);

  const fetchSession = useCallback((currentItem: number, itemsPerPage: number) => {
    SessionPage(currentItem, itemsPerPage).then((item: types.SessionContainer) => {
      if (item) {
        setSession(item);
      }
    });
  }, []);

  const fetchAppInfo = () => {
    GetAppInfo().then((info) => {
      setChain(info.chain);
      setMeta(info.meta);
      setWizardState(info.state);
      setIsConfigured(info.isConfigured);
      setInfo(info);
    });
  };

  const selectChain = (newChain: string) => {
    setChain(newChain);
    SetChain(newChain, address) // disables refresh
      .then(() => {})
      .catch((error) => {
        console.error("Error setting chain:", error);
      });
  };

  useEffect(() => {
    fetchHistory(0, 15);
    HistoryPage(address as unknown as string, 0, 15).then((item: types.HistoryContainer) => {
      setHistory(item);
    });
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(() => {
    const handleRefresh = () => {
      fetchAppInfo();
      fetchStatus(0, 100);
    };
    handleRefresh(); // first load

    // when messaged
    const { Message } = messages;
    EventsOn(Message.DAEMON, handleRefresh);
    EventsOn(Message.WIZARD, handleRefresh);
    return () => {
      EventsOff(Message.DAEMON);
      EventsOff(Message.WIZARD);
    };
  }, []);

  const state = {
    project,
    fetchProject,
    history,
    fetchHistory,
    monitors,
    fetchMonitors,
    names,
    fetchNames,
    abis,
    fetchAbis,
    indexes,
    fetchIndexes,
    manifests,
    fetchManifests,
    settings,
    fetchSettings,
    status,
    fetchStatus,
    session,
    fetchSession,
    address,
    info,
    chain,
    meta,
    isConfigured,
    wizardState,
    setHistory,
    setAddress,
    selectChain,
    setMeta,
    setWizardState,
  };

  return <AppState.Provider value={state}>{children}</AppState.Provider>;
};

export const useAppState = () => {
  const context = useContext(AppState);
  if (!context) {
    throw new Error("useAppState must be used within a AppStateProvider");
  }
  return context;
};
